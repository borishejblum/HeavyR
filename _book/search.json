[{"path":"index.html","id":"course-syllabus","chapter":"Course syllabus","heading":"Course syllabus","text":"main goal course give tools ease (high-performing effcient) code development . performance side come second part, initial tools introduced also useful situations require\nimportant computation times.focus presentation development tools focuusing notion package. already familiar notion, already\nalready installed packages CRAN example ! also know standard way  distribuute code make available.\nshow package also excellent tool developing code.follow outline :Build packageBuild packageTracking changes, sharing code, collaborative development automating tests packageTracking changes, sharing code, collaborative development automating tests packageMeasure computation timeMeasure computation timeProfile codeProfile codeUse Rcpp optimize needs optimizedUse Rcpp optimize needs optimizedParallelize code easilyParallelize code easilyTo take course, need following softwares installed:latest version  (https://cloud.r-project.org/)latest version  (https://cloud.r-project.org/)latest version RStudio (https://www.rstudio.com/products/rstudio/download/#download)latest version RStudio (https://www.rstudio.com/products/rstudio/download/#download)C++ compiler (gcc clang - native UNIX systems,\nWindows users recommend installing\nRtools, \nMac users may necessary install macOS tool chain (namely Xcode Command Line Tools gfortran) used  detailed )C++ compiler (gcc clang - native UNIX systems,\nWindows users recommend installing\nRtools, \nMac users may necessary install macOS tool chain (namely Xcode Command Line Tools gfortran) used  detailed )following  packages: devtools, future.apply, itertools, microbenchmark, mvtnorm, profvis, Rcpp, RcppArmadillo, roxygen2, testthat, usethisthe following  packages: devtools, future.apply, itertools, microbenchmark, mvtnorm, profvis, Rcpp, RcppArmadillo, roxygen2, testthat, usethisthe software gitthe software git","code":""},{"path":"building-a-package.html","id":"building-a-package","chapter":"1 Building a  package","heading":"1 Building a  package","text":"present efficiently create build package using Rstudio IDE, devtools usethis packages.details provided reference material subject: book R packages Hadley Wickham, freely available online.","code":""},{"path":"building-a-package.html","id":"initializing-a-package","chapter":"1 Building a  package","heading":"1.1 Initializing a package","text":"simple way, built Rstudio, initialize package :create new project (top left File drop menu Rstudio)create new project (top left File drop menu Rstudio)choose “New Directory”choose “New Directory”choose “R package using devtools” (available, choose “R\npackage”, difference “R package” delete unnecessary files automatically created useful)choose “R package using devtools” (available, choose “R\npackage”, difference “R package” delete unnecessary files automatically created useful)give name package, example mypkgr.give name package, example mypkgr., get minimal structure  package, namely:DESCRIPTION file whose Title, Version, Authors@R \nDescription edited (parts can edited even added automatically, see\neven added automatically, see )DESCRIPTION file whose Title, Version, Authors@R \nDescription edited (parts can edited even added automatically, see\neven added automatically, see )NAMESPACE file later edited automatically\n(hands now)NAMESPACE file later edited automatically\n(hands now)folder R add .R script filesa folder R add .R script filesdevtools also adds three optional files:.gitignore, relative git, version control tool see detail\nsection GitHub.gitignore, relative git, version control tool see detail\nsection GitHubmypkgr.Rproj specific file Rstudio, allows define\ncharacteristics preferences project just createdmypkgr.Rproj specific file Rstudio, allows define\ncharacteristics preferences project just created.Rbuildignore allows ignore files build package road (example, mypkgr.Rproj file included package).Rbuildignore allows ignore files build package road (example, mypkgr.Rproj file included package)","code":""},{"path":"building-a-package.html","id":"adding-a-function-common-theme-example","chapter":"1 Building a  package","heading":"1.2 Adding a function: common theme example","text":"first invite code following function, use throughout course:want compute value density multivariate normal distribution\n\\(\\mathbb{R}^p\\) \\(n\\) points. function must applicable \nmultivariate normal distribution (.e. mean vector \n\\(\\mathbb{R}^p\\) variance-covariance matrix order \\(p\\)),\nwish compute values density evaluated\n\\(n\\) points single call function.need create function mvnpdf() file named mvnpdf.R\n folder package, :takes arguments:\nx matrix, \\(n\\) columns (observations) \\(p\\) rows\nmean vector means\nvarcovM variance-covariance matrix\nLog logical parameter, default value TRUE.\ntakes arguments:x matrix, \\(n\\) columns (observations) \\(p\\) rowsx matrix, \\(n\\) columns (observations) \\(p\\) rowsmean vector meansmean vector meansvarcovM variance-covariance matrixvarcovM variance-covariance matrixLog logical parameter, default value TRUE.Log logical parameter, default value TRUE.returns list containing matrix x, vector length \\(n\\)\nmultivariate normal distribution density values points.returns list containing matrix x, vector length \\(n\\)\nmultivariate normal distribution density values points.👉 turn !⚠️ **WARNING ! click quickly link , invalidate participation class !function proposal can download\n.advice writing code, see \nR code section Hadley Wickam R packages online book.","code":""},{"path":"building-a-package.html","id":"documenting-a-function","chapter":"1 Building a  package","heading":"1.3 Documenting a function","text":"important properly document code. Every project least 2\ndevelopers:,,6 months.6 months.sake future self, favor take time document\ncode !strongly advise use roxygen2 package document\npackages. main advantage help function \nfile code defining function.👉 turn!Start inserting skeleton helper “Insert Roxygen\nSkeleton” located “Code” menu Magic Wand sub-menu \nscript window.Start inserting skeleton helper “Insert Roxygen\nSkeleton” located “Code” menu Magic Wand sub-menu \nscript window.Complete documentation filling :Complete documentation filling :title function (first line)title function (first line)description function (second paragraph)description function (second paragraph)fill third paragraph, part go “Details” section \nhelp pageif fill third paragraph, part go “Details” section \nhelp pagethe meaning parametersthe meaning parametersthe output, @return tagthe output, @return tagGenerate documentation using “Document” “” menu \nBuild” tab (Ctrl+Shift+D devtools::document()). effect \ncommand multiple:man folder created inside , mvnpdf.Rd file contains help information functiona man folder created inside , mvnpdf.Rd file contains help information functionthe NAMESPACE file modifiedthe NAMESPACE file modifiedIn case problems curiosity done, can look \nproposal.details package documentation \nroxygen2 tags, see \nObject documentation secttion Hadley Wickam R packages online book.Let’s finish mentioning function usethis package initializes \nhome help page whole package:generated help page accessible, package installed,\nfollowing command:","code":"\nusethis::use_package_doc()\n?mypkgr"},{"path":"building-a-package.html","id":"interactively-test-the-package","chapter":"1 Building a  package","heading":"1.4 Interactively test the package","text":"test package, load R using “Load ” (Ctrl+Shift+L) \n“” menu “Build” tab, alternatively devtools::load_all()).can use package directly R: see\nhelp function ?mvnpdf example execute commands given example section help page.code development, can thus:Add/Modify  codeAdd/Modify  codeRe-load package Ctrl+Shift+LRe-load package Ctrl+Shift+LExperiment consoleExperiment consoleAnd ……","code":"\n?mvndpf"},{"path":"building-a-package.html","id":"automatically-test-your-package","chapter":"1 Building a  package","heading":"1.5 Automatically test your package","text":"initialize automatic testing capabilities package, execute following command:command creates tests folder includes testthat.R file – modified – testthat folder add automated tests. tool based theory unit tests.example, content file call test-univariate.R put testthat folder:second one named test-bivariate.R :execute tests, can click “Test package” (Ctrl+Shift+T) “” menu “Build” tab, run devtools::test()advantage automatic tests run every time check package.good practice add unit test time bug identified fixed,\ncan immediately identify prevent error happening \nfuture.","code":"\nusethis::use_testthat()\ncontext(\"Univariate gaussian test\")\n\ntest_that(\"correct result for univariate gaussian\", {\n  expect_equal(mvnpdf(x=matrix(1.96), Log=FALSE)$y, dnorm(1.96))\n  expect_equal(mvnpdf(x=matrix(c(1.96, -0.5), ncol = 2), Log=FALSE)$y,\n               dnorm(c(1.96, -0.5)))\n})\ncontext(\"Bivariate gaussian test\")\n\ntest_that(\"correct results for bivariate gaussian\", {\n  expect_equal(mvnpdf(x=matrix(rep(1.96,2), nrow=2, ncol=1), Log=FALSE)$y,\n               mvtnorm::dmvnorm(rep(1.96, 2)))\n})"},{"path":"building-a-package.html","id":"checking-your-package","chapter":"1 Building a  package","heading":"1.6 Checking your package","text":"Ruunning check means ensuring tthat everything package correct work expected, can installed properly.\n“Passing R CMD CHECK” mandatory successfully uploading package CRAN.perform R CMD CHECK package, can click “Check” (Ctrl+Shift+E) “Build” tab, run devtools::check().check, automated unitt tests developed previously \nexecuted. advantage written tests, don’t need worry , simply react adjust code errors returned flagged.","code":""},{"path":"building-a-package.html","id":"install-your-package","chapter":"1 Building a  package","heading":"1.7 Install your package","text":"moment, package exists environment associated Rstudio project created. able use anywhere (computer)  general way, install (like CRAN package example)., click “Install Restart” (Ctrl+Shift+B) “Build” tab, alternatively can run devtools::install().finally, can configure Rstudio’s behavior time installation, simultaneously documents package: go “” menu “Build” tab, “Configure Build Tools”. click “Configure” check box bottom “Install Restart”.","code":""},{"path":"building-a-package.html","id":"appendix-1.1-add-an-s3-method","chapter":"1 Building a  package","heading":"1.8 Appendix 1.1: add an S3 method","text":"packages, oftten implement called S3 methods , result object res, one can run print(res), summary(res), plot(res)…example plot() method can add package:⚠️ Warning !order S3 method want apply \nresult function mvnpdf(), declare mvnpdf() returns result class mvnpdf.Test function, executing example.\n*Don’t forget reinstall package (“Install Restart” Ctrl+Shift+B).Look contents man folder changes made NAMESPACE.proposed solution: file\ncontains complete code mvnpdf() function associated plot() method.","code":"\n#' Plot of the mvnpdf function\n#'\n#' @param x an object of class \\code{mvnpdf} resulting from a call of\n#' \\code{mnvpdf()} function.\n#' @param ... graphical parameters passed to \\code{plot()} function.\n#'\n#' @return Nothing is returned, only a plot is given.\n#' @export\n#'\n#' @examples\n#' pdfvalues <- mvnpdf(x=matrix(seq(-3, 3, by = 0.1), nrow = 1), Log=FALSE)\n#' plot(pdfvalues)\nplot.mvnpdf <- function(x, ...) {\n  plot(x$x, x$y, type = \"l\", ...)\n}"},{"path":"building-a-package.html","id":"appendix-1.2-submit-ones-package-on-cran","chapter":"1 Building a  package","heading":"1.9 Appendix 1.2: submit one’s package on CRAN","text":"Run two following commands: devtools::check() followed devtools::submit_cran().\ndetails, see Hadley Wickham’s recommanded pipeline book R packages","code":""},{"path":"contrôle-de-version-avec-git-et-github-historique-de-changement-développement-collaboratif-et-intégration-continue.html","id":"contrôle-de-version-avec-git-et-github-historique-de-changement-développement-collaboratif-et-intégration-continue","chapter":"2 Contrôle de version avec git et GitHub : historique de changement, développement collaboratif et intégration continue","heading":"2 Contrôle de version avec git et GitHub : historique de changement, développement collaboratif et intégration continue","text":"Nous nous intéressons ici aux solutions proposées par RStudio et GitHub pour\nl’hébergement et le contrôle de version de projets.","code":""},{"path":"contrôle-de-version-avec-git-et-github-historique-de-changement-développement-collaboratif-et-intégration-continue.html","id":"principe-du-contrôle-de-version","chapter":"2 Contrôle de version avec git et GitHub : historique de changement, développement collaboratif et intégration continue","heading":"2.1 Principe du contrôle de version","text":"Le principe du contrôle de version est d’enregistrer les changements\nsuccessifs apportés à des fichiers (notamment des fichiers R).RStudio propose 2 solutions intégrées pour le contrôle de version :gitgitsvnsvn","code":""},{"path":"contrôle-de-version-avec-git-et-github-historique-de-changement-développement-collaboratif-et-intégration-continue.html","id":"git","chapter":"2 Contrôle de version avec git et GitHub : historique de changement, développement collaboratif et intégration continue","heading":"2.1.1 git","text":"git est un logiciel de contrôle de version (c’est-à-dire un outils qui va\nenregistrer l’histoire des changements successifs de votre code et permettre de\npartager ces changements avec d’autres personnes). git est un logiciel en\nligne de commande, et sa prise en main n’est pas nécessairement intuitive.git fonctionne de la façon suivante : sur un serveur dans le ‘cloud’,\nune version à jour du code est disponible. À tout moment il est possible\nd’accéder à cette version du code en ligne. Chaque contributeur peut télécharger\ncette dernière version à jour (dans une action que l’dénomme pull),\navant de l’éditer localement. Une fois ses changements effectués, le\ncontributeur peut alors mettre à jour la version en ligne du code afin que ses\nchangements soient disponibles pour tout le monde (dans une action que l’\ndénomme push)NB : git été pensé pour des fichiers légers (comme par exemple des\nfichiers texte) et est loin d’être optimisé pour des fichiers trop lourds et/où\ncompressés.","code":""},{"path":"contrôle-de-version-avec-git-et-github-historique-de-changement-développement-collaboratif-et-intégration-continue.html","id":"subversion","chapter":"2 Contrôle de version avec git et GitHub : historique de changement, développement collaboratif et intégration continue","heading":"2.1.2 subversion","text":"subversion est l’autre solution disponible dans RStudio. Elle fonctionne de\nmanière similaire à git, mais avec des fonctionnalités un peu plus réduites\nque nous détaillons pas ici (la différence majeure est que tout les\ncontributeurs travaillent simultanément sur la même version du code).","code":""},{"path":"contrôle-de-version-avec-git-et-github-historique-de-changement-développement-collaboratif-et-intégration-continue.html","id":"utiliser-git-localement-depuis-rstudio","chapter":"2 Contrôle de version avec git et GitHub : historique de changement, développement collaboratif et intégration continue","heading":"2.2 Utiliser git localement depuis RStudio","text":"vous de jouer !Commencez par activer git depuis l’onglet “Git/SVN” de “Project Options”\nsitué dans le menu “Tools” et suivre les instructions. Vous pouvez aussi\nutilisé usethis::use_git()Commencez par activer git depuis l’onglet “Git/SVN” de “Project Options”\nsitué dans le menu “Tools” et suivre les instructions. Vous pouvez aussi\nutilisé usethis::use_git()À partir de l’onglet “Git” maintenant apparu à côté de l’onglet “Build”,\nenregistrer l’état actuel de votre package en réalisant votre premier “commit” :À partir de l’onglet “Git” maintenant apparu à côté de l’onglet “Build”,\nenregistrer l’état actuel de votre package en réalisant votre premier “commit” :2a. sélectionner les fichiers à suivre (ne pas sélectionner le fichier .Rproj)2a. sélectionner les fichiers à suivre (ne pas sélectionner le fichier .Rproj)2b. écrire un message informatif (pour vos collaborateurs - ce qui inclut votre futur vous)2b. écrire un message informatif (pour vos collaborateurs - ce qui inclut votre futur vous)2c. cliquer sur “Commit”2c. cliquer sur “Commit”Ajouter une ligne “*.Rproj” au fichier “.gitignore” et effectuez un nouveau commitAjouter une ligne “*.Rproj” au fichier “.gitignore” et effectuez un nouveau commitVisualiser les changements et leur historique à l’aide des outils de visualisation\n“Diff” et “History” accessible depuis l’onglet “Git”Visualiser les changements et leur historique à l’aide des outils de visualisation\n“Diff” et “History” accessible depuis l’onglet “Git”","code":""},{"path":"contrôle-de-version-avec-git-et-github-historique-de-changement-développement-collaboratif-et-intégration-continue.html","id":"bonnes-pratiques-du-commit","chapter":"2 Contrôle de version avec git et GitHub : historique de changement, développement collaboratif et intégration continue","heading":"2.2.1 Bonnes pratiques du commit","text":"Idéalement, chaque commit ne devrait régler qu’un seul problème. Il devrait le régler dans\nson intégralité (être complet) et ne contenir des changements relatifs qu’uniquement à\nce problème (être minimal). Il est alors important d’écrire des message de commit\ninformatifs (pensez à vos collaborateur, qui incluent votre futur vous).\nIl faut également être concis, et décrire les raisons des changements plutôt que\nles changements eux-mêmes (visibles dans le Diff). Il est parfois difficile de\nrespecter ces directives à la lettre, et celles-ci ne sont qu’un guide et ne\ndoivent pas vous empêcher d’effectuer des commits réguliers.Par ailleurs, la tentation d’avoir un historique de changements “propre” et bien\nordonné est naturelle, mais se révèle une source de problèmes inutiles. Elle\nentre en contradiction avec l’objectif de traçabilité du contrôle de version.\nLe développement de code étant généralement un processus intellectuel complexe\net non linéaire, il est normal que l’enregistrement des changements reflète ce\ncheminement. En pratique, votre futur-vous sera le premier utilisateur de votre\nhistorique de changements et la priorité est donc de vous faciliter la tache\ndans le futur lors de la résolution de bug où l’extension de fonctionnalités.","code":""},{"path":"contrôle-de-version-avec-git-et-github-historique-de-changement-développement-collaboratif-et-intégration-continue.html","id":"github","chapter":"2 Contrôle de version avec git et GitHub : historique de changement, développement collaboratif et intégration continue","heading":"2.3 GitHub","text":"GitHub est un site internet proposant une solution\nd’hébergement de code en ligne, et s’appuyant sur git. Il existe de nombreux\nsites web et services (gitlab, bitbucket, …) permettant d’héberger du code et\ns’appuyant sur git. GitHub est très populaire dans la communauté des\ndéveloppeurs , et est relativement facile à utiliser, même pour un\nutilisateur novice.Les avantages d’utiliser GitHub :une interface graphique simple pour suivre l’historique des changements de votre codeune interface graphique simple pour suivre l’historique des changements de votre codela dernière version de développement de votre code est disponible en ligne et vous pouvez la\nréférencer (peut même référencer un numéro de commit précis pour geler une version spécifique\ndu code)la dernière version de développement de votre code est disponible en ligne et vous pouvez la\nréférencer (peut même référencer un numéro de commit précis pour geler une version spécifique\ndu code)les utilisateurs disposent d’un canal clair et transparent pour signaler les bugs/difficultésles utilisateurs disposent d’un canal clair et transparent pour signaler les bugs/difficultéscela facilite grandement le développement collaboratifcela facilite grandement le développement collaboratif","code":""},{"path":"contrôle-de-version-avec-git-et-github-historique-de-changement-développement-collaboratif-et-intégration-continue.html","id":"mettre-son-package-sur-github","chapter":"2 Contrôle de version avec git et GitHub : historique de changement, développement collaboratif et intégration continue","heading":"2.3.1 Mettre son package  sur GitHub","text":"vous de jouer !Rendez-vous sur le site https://github.com/ et créez vous un compte\nGitHub (si vous hésitez, une convention courante est d’utiliser prénomnom comme nom d’utilisateur)Rendez-vous sur le site https://github.com/ et créez vous un compte\nGitHub (si vous hésitez, une convention courante est d’utiliser prénomnom comme nom d’utilisateur)Vous pouvez ensuite soit utiliser le client “GitHub desktop” installé sur votre machine en vous connectant au compte GitHub et en suivant les instructions 3 et 4 suivantes, soit utiliser usethis::use_github() et vous laisser guider.Vous pouvez ensuite soit utiliser le client “GitHub desktop” installé sur votre machine en vous connectant au compte GitHub et en suivant les instructions 3 et 4 suivantes, soit utiliser usethis::use_github() et vous laisser guider.Ajouter un nouveau projet local en cliquant sur l’icone “+” en haut à gauche de\nla fenêtre du client, puis en choississant “Add” et en rentrant le chemin du dossier\noù se trouve le code de votre package.Ajouter un nouveau projet local en cliquant sur l’icone “+” en haut à gauche de\nla fenêtre du client, puis en choississant “Add” et en rentrant le chemin du dossier\noù se trouve le code de votre package.Une fois le repertoire créer en local, publiez le sur GitHub en cliquant sur “Publish”\nen haut à droite de la fenêtre du client. Vérifiez sur le site de GitHub que votre\ncode à bien été uploadé avec les 2 commits précédents.Une fois le repertoire créer en local, publiez le sur GitHub en cliquant sur “Publish”\nen haut à droite de la fenêtre du client. Vérifiez sur le site de GitHub que votre\ncode à bien été uploadé avec les 2 commits précédents.Ajouter un fichier “README.Rmd” à votre package afin de disposer d’une belle page\nd’accueil sur GitHub :Ajouter un fichier “README.Rmd” à votre package afin de disposer d’une belle page\nd’accueil sur GitHub :5a. dans RStudio, executez la commande usethis::use_readme_rmd()5a. dans RStudio, executez la commande usethis::use_readme_rmd()5b. à l’aide de l’outilds “Diff” de l’onglet “Git” de RStudio, étudier\nles changements opérer par la commande précédente5b. à l’aide de l’outilds “Diff” de l’onglet “Git” de RStudio, étudier\nles changements opérer par la commande précédente5c. éditez le fichier “README.Rmd” créé, puis créer le fichier README.md\ncorrespondant en executant knitr (cliquer su la pelotte de laine “Knit”\nen haut à gauche dans Rstudio), avant d’effectuer un 3e commit contenant ces\nchangements5c. éditez le fichier “README.Rmd” créé, puis créer le fichier README.md\ncorrespondant en executant knitr (cliquer su la pelotte de laine “Knit”\nen haut à gauche dans Rstudio), avant d’effectuer un 3e commit contenant ces\nchangements5d. à ce stade, si vous visitez la page de votre répertoire sur GitHub,\nvotre 3e commit n’apparait pour l’instant pas. Il faut synchroniser\nle répertoire GitHub en ligne avec votre dossier local. Pour cela, vous\navez 2 solutions : soit utiliser le bouton “Sync” en haut à droit de la\nfenêtre du client GitHub desktop ; soit directement depuis RStudio en cliquant\nsur “Push” depuis l’onglet “Git”. Maintenant, les changements du 3e commit sont\nvisibles en ligne dur GitHub.5d. à ce stade, si vous visitez la page de votre répertoire sur GitHub,\nvotre 3e commit n’apparait pour l’instant pas. Il faut synchroniser\nle répertoire GitHub en ligne avec votre dossier local. Pour cela, vous\navez 2 solutions : soit utiliser le bouton “Sync” en haut à droit de la\nfenêtre du client GitHub desktop ; soit directement depuis RStudio en cliquant\nsur “Push” depuis l’onglet “Git”. Maintenant, les changements du 3e commit sont\nvisibles en ligne dur GitHub.","code":""},{"path":"contrôle-de-version-avec-git-et-github-historique-de-changement-développement-collaboratif-et-intégration-continue.html","id":"collaboration-pour-la-production-du-code","chapter":"2 Contrôle de version avec git et GitHub : historique de changement, développement collaboratif et intégration continue","heading":"2.4 Collaboration pour la production du code","text":"git et GitHub sont particulièrement efficaces lorsque plusieurs personnes collaborent pour\ndévelopper un code. En effet, chacun peut effectuer des pull et push successifs pour\napporter des changements au code, de manière simultanée et en étant sûr de toujours travailler\nsur la dernière version. Nous allons voir différents concepts utiles dans le cas d’un tel travail\ncollaboratif.vous de jouer !En formant des groupes de 2, vous allez chacun ajouter votre binome comme “collaborator”\nà votre repertoire GitHub à partir de l’onglet “Settings” (sur GitHub).En formant des groupes de 2, vous allez chacun ajouter votre binome comme “collaborator”\nà votre repertoire GitHub à partir de l’onglet “Settings” (sur GitHub).Quelques instants plus tard le collaborateur ainsi ajouté reçoit un email l’invitant à\naccepter l’ajout. Cliquer sur le lien et accepter.Quelques instants plus tard le collaborateur ainsi ajouté reçoit un email l’invitant à\naccepter l’ajout. Cliquer sur le lien et accepter.Dans le client “GitHub desktop”, ajouter le répertoire de votre binôme en cliquant sur\nl’icone “+” en haut à gauche et en selectionnant “Clone”, ce qui fait apparaitre la liste\ndes repertoires associés à votre compte GitHub non liés à un dossier local.\nSélectionner le projet de votre binome.Dans le client “GitHub desktop”, ajouter le répertoire de votre binôme en cliquant sur\nl’icone “+” en haut à gauche et en selectionnant “Clone”, ce qui fait apparaitre la liste\ndes repertoires associés à votre compte GitHub non liés à un dossier local.\nSélectionner le projet de votre binome.","code":""},{"path":"contrôle-de-version-avec-git-et-github-historique-de-changement-développement-collaboratif-et-intégration-continue.html","id":"branches","chapter":"2 Contrôle de version avec git et GitHub : historique de changement, développement collaboratif et intégration continue","heading":"2.4.1 Branches","text":"Une des fonctionnalités assez utile de git est les branches. Cela permet d’opérer des changements\nimportants dans le code sans perturber le fonctionnement actuel. C’est notamment utile pour explorer\nune piste de développement dont ne sait pas si elle sera concluante au final.D’ailleurs, vous utilisez déjà les branches depuis le depuis de cette partie. En effet, la branche\npar défaut est appelé “master”.Grâce à ce système de branches, obtient un arbre des différents commits au cours du temps (où\nles nœuds correspondent à la séparations des branches).","code":""},{"path":"contrôle-de-version-avec-git-et-github-historique-de-changement-développement-collaboratif-et-intégration-continue.html","id":"merge","chapter":"2 Contrôle de version avec git et GitHub : historique de changement, développement collaboratif et intégration continue","heading":"2.4.2 Merge","text":"Un pull se décompose en 2 actions de la part de git :tout d’abord un fetch, qui correspond au téléchargement du code en lignetout d’abord un fetch, qui correspond au téléchargement du code en lignesuivi d’un merge qui fusionne la version locale avec les changements.suivi d’un merge qui fusionne la version locale avec les changements.Après avoir conduit un développement expérimental dans une branche, peut vouloir merger ces\nchangements dans la branche “master” par exemple, après que l’expérience se soit révélée\nconcluante.Si un les changements concernent des parties distinctes du code, alors le merge peut\ns’effectuer sans problème. En revanche si les 2 versions à merger comportent des changements\ndepuis leur dernier commit commun qui concerne les mêmes lignes de codes, alors va rencontrer\nun (ou des ) conflit(s), qu’il va falloir résoudre.","code":""},{"path":"contrôle-de-version-avec-git-et-github-historique-de-changement-développement-collaboratif-et-intégration-continue.html","id":"les-conflits","chapter":"2 Contrôle de version avec git et GitHub : historique de changement, développement collaboratif et intégration continue","heading":"2.4.3 Les conflits","text":"Prenons l’exemple suivant : le développeur \\(D_1\\) et le développeur \\(D_2\\) tous les 2 pullé la\nversion v0.1 du code à l’instant \\(t\\) sur leur machine respective. Ils travaillent chacun\nindépendamment pour apporter des changements au code. Au moment de pusher ses changements,\nle développeur \\(D_2\\) reçoit un message d’erreur :“Sync Error.\nPlease resolve conflicted files, commit, try syncing .”Chaque fichier étant source de conflit alors été automatiquement édité comme suit :Pour résoudre le conflit, il faut alors éditer chaque fichier un à un en choisissant s’il faut\nconserver la version locale ou bien celle en ligne, avant de pouvoir commiter à nouveau et enfin\nde pusher vos changements avec succès.vous de jouer !Modifiez le fichier README.Rmd de votre binome, puis commitez votre changement et pushez\nle.Modifiez le fichier README.Rmd de votre binome, puis commitez votre changement et pushez\nle.une fois que votre binôme modifié votre README.Rmd, modifiez à votre tour le fichier\nà la même ligne, SANS puller les changements de votre binôme au préalable ! Commitez et\nessayez de pusher ces changements.une fois que votre binôme modifié votre README.Rmd, modifiez à votre tour le fichier\nà la même ligne, SANS puller les changements de votre binôme au préalable ! Commitez et\nessayez de pusher ces changements.Résolvez le conflit.Résolvez le conflit.","code":"<<<<<<< HEAD\ncode dans votre version local\n=======\ncode en ligne\n>>>>>>> remote"},{"path":"contrôle-de-version-avec-git-et-github-historique-de-changement-développement-collaboratif-et-intégration-continue.html","id":"fork","chapter":"2 Contrôle de version avec git et GitHub : historique de changement, développement collaboratif et intégration continue","heading":"2.4.4 Fork","text":"L’action fork permet de créer une copie qui vous appartient à partir d’un code disponible. Ainsi\nle code original ne sera pas impacté par vos changements. Cela revient à créer une branche, et la\nséparer de l’arbre pour pouvoir en assumer la propriété.Cette action est principalement utile dans le cadre des pull requests.","code":""},{"path":"contrôle-de-version-avec-git-et-github-historique-de-changement-développement-collaboratif-et-intégration-continue.html","id":"pull-request","chapter":"2 Contrôle de version avec git et GitHub : historique de changement, développement collaboratif et intégration continue","heading":"2.4.5 Pull request","text":"Il s’agit du moyen le plus facile de proposer des changements dans un code dont vous n’êtes pas\ncollaborateur. GitHub propose une interface graphique facilitant leur traitement.vous de jouer !Modifiez le README.Rmd de votre voisin qui n’est pas votre binôme après avoir forké son\npackage.Modifiez le README.Rmd de votre voisin qui n’est pas votre binôme après avoir forké son\npackage.Proposez votre changement sous la forme d’une pull request.Proposez votre changement sous la forme d’une pull request.Acceptez la pull request sur le site de GitHub et faire le merge.Acceptez la pull request sur le site de GitHub et faire le merge.","code":""},{"path":"contrôle-de-version-avec-git-et-github-historique-de-changement-développement-collaboratif-et-intégration-continue.html","id":"issues","chapter":"2 Contrôle de version avec git et GitHub : historique de changement, développement collaboratif et intégration continue","heading":"2.4.6 Issues","text":"Pour n’importe quel répertoire GitHub, vous pouvez poster un commentaire sous forme d’issue\nafin d’alerter les développeurs sur un éventuel bug, ou une question sur l’utilisation du package,\nou encore demander une fonctionnalité supplémentaire…L’idéal est de proposer vous-même une pull request qui résout votre issue lorsque vous\nle pouvez (.e. en avez les capacités et le temps).vous de jouer !Utilisez usethis::use_github_links() afin d’ajouter les 2 lignes suivantes au fichier DESCRIPTION de votre packageURL: http://github.com/*prenom.nom*/mypkgBugReports: http://github.com/*prenom.nom*/mypkg/issuesUtilisez usethis::use_github_links() afin d’ajouter les 2 lignes suivantes au fichier DESCRIPTION de votre packageURL: http://github.com/*prenom.nom*/mypkgBugReports: http://github.com/*prenom.nom*/mypkg/issuesVisualisez les nouveau changements, puis commitez les.Visualisez les nouveau changements, puis commitez les.Créez une issue sur le projet de votre binomeCréez une issue sur le projet de votre binome","code":""},{"path":"contrôle-de-version-avec-git-et-github-historique-de-changement-développement-collaboratif-et-intégration-continue.html","id":"intégration-continue","chapter":"2 Contrôle de version avec git et GitHub : historique de changement, développement collaboratif et intégration continue","heading":"2.5 Intégration continue","text":"À chaque changement, à chaque commit donc, il y la possibilité d’introduire 1 (ou plusieurs)\nbugs qui vont empêcher le package de passer le CRAN check. Si l’accumule trop de ces bugs,\nau moment de soumettre la nouvelle version, il peut y avoir beaucoup de corrections à apporter.\nC’est d’autant plus frustrant si le package passait le CRAN check auparavant…Les services d’intégration continue permettent de checker votre package automatiquement après\nchaque commit ! En cas d’échec, vous recevez un mail qui vous en informe. Un certain nombre de ces\nservices proposent une offre limitée gratuite pour les projets open-source.Une autre raison d’utiliser l’intégration continue est qu’elle permet de tester votre package sur\ndes infrastructures différentes de la votre (e.g. Windows, Ubuntu, Mac OS) et pour différentes\nversions de  (current, devel…)","code":""},{"path":"contrôle-de-version-avec-git-et-github-historique-de-changement-développement-collaboratif-et-intégration-continue.html","id":"github-actions","chapter":"2 Contrôle de version avec git et GitHub : historique de changement, développement collaboratif et intégration continue","heading":"2.5.1 Github actions","text":"Les Github actions permettent de lancer des actions automatiquement à chaque fois que vous pushez sur github. La commande usethis::use_github_action_check_standard() permet d’initialiser les Github actions et d’ajouter l’action de check du package.vous de jouer !Executez la commande usethis::use_github_action_check_standard() et commitez les changements et regardez ce\nqu’il se passe sur page githubExecutez la commande usethis::use_github_action_check_standard() et commitez les changements et regardez ce\nqu’il se passe sur page githubAjouter un badge à votre README.md grâce au code obtenu dans la console R\net commitez les changementsAjouter un badge à votre README.md grâce au code obtenu dans la console R\net commitez les changementsN’hésitez pas à consulter la page suivantes qui renseigne sur les différentes github actions pour les pacakges : https://github.com/r-lib/actions/blob/v1/examples/README.md","code":""},{"path":"contrôle-de-version-avec-git-et-github-historique-de-changement-développement-collaboratif-et-intégration-continue.html","id":"annexe-2.1-couverture-du-code","chapter":"2 Contrôle de version avec git et GitHub : historique de changement, développement collaboratif et intégration continue","heading":"2.6 Annexe 2.1 : couverture du code","text":"Le package covr propose une solution pour mesurer la couverture des tests unitaires associés à un\npackage. La couverture de test détermine la proportion du code source qui est effectivement utilisée\nlors de l’exécution des tests unitaires. La mesure de la couverture du code renforce la fiabilité\nd’un code et donne confiance à ses utilisateurs potentiels.vous de jouer !Executez la commande usethis::use_coverage(), ajouter un joli badge à votre README.md grâce au code obtenu dans la console RCommitez ces changements.Pour plus d’information n’hésitez pas à consulter la vignette de covr.","code":""},{"path":"mesurer-et-comparer-des-temps-dexécution.html","id":"mesurer-et-comparer-des-temps-dexécution","chapter":"3 Mesurer et comparer des temps d’exécution","heading":"3 Mesurer et comparer des temps d’exécution","text":"La première étape avant d’optimiser un code est de pouvoir mesurer son temps d’exécution,\nafin de pouvoir comparer les temps d’exécution entre différente implémentations.","code":""},{"path":"mesurer-et-comparer-des-temps-dexécution.html","id":"mesurer-des-temps-dexécution-avec-system.time","chapter":"3 Mesurer et comparer des temps d’exécution","heading":"3.1 Mesurer des temps d’exécution avec system.time()","text":"Pour mesure le temps d’exécution d’une commande R, peut utiliser la\nfonction system.time() comme ceci :Le problème qui apparaît sur cet exemple est que l’exécution est tellement\nrapide que system.time() affiche 0 (ou une valeur très proche).\nDe plus, voit qu’il y une certaine variabilité quand relance plusieurs\nfois la commande.Ainsi si souhaite comparer notre code avec la fonction mvtnorm::dmvnorm(),\nne peut pas utiliser system.time() :pourrait se dire qu’il faut augmenter la complexité de notre calcul, mais\nil y mieux : utiliser le package microbenchmark !","code":"\nsystem.time(mvnpdf(x=matrix(rep(1.96, 2), nrow=2, ncol=1), Log=FALSE))## utilisateur     système      écoulé \n##       0.001       0.001       0.003\nsystem.time(mvtnorm::dmvnorm(rep(1.96, 2)))## utilisateur     système      écoulé \n##       0.002       0.001       0.006"},{"path":"mesurer-et-comparer-des-temps-dexécution.html","id":"comparer-des-temps-dexécution-avec-microbenchmark","chapter":"3 Mesurer et comparer des temps d’exécution","heading":"3.2 Comparer des temps d’exécution avec microbenchmark()","text":"Comme son nom l’indique, ce package permet justement de comparer des temps\nd’exécution même quand ceux-ci sont très faibles. De plus, la fonction\nmicrobenchmark() va répéter un certain nombre de fois l’exécution des\ncommandes et donc va stabiliser le résultat.Les deux fonctions mvnpdf() et dmnvorm() étant capables de prendre en\nentrée une matrice, peut également comparer leurs comportements dans ce\ncas :Il s’est passé un quelque chose… Et va diagnostiquer ce problème dans la suite.","code":"\nlibrary(microbenchmark)\nmb <- microbenchmark(mvtnorm::dmvnorm(rep(1.96, 2)),\n                     mvnpdf(x=matrix(rep(1.96,2)), Log=FALSE),\n                     times=1000L)\nmb## Unit: microseconds\n##                                           expr    min     lq     mean median\n##                 mvtnorm::dmvnorm(rep(1.96, 2)) 30.237 34.058 52.02946 38.833\n##  mvnpdf(x = matrix(rep(1.96, 2)), Log = FALSE) 28.492 31.496 45.28976 34.846\n##      uq      max neval cld\n##  56.644 2486.725  1000   b\n##  52.124  238.796  1000  a## Warning: It is deprecated to specify `guide = FALSE` to remove a guide. Please\n## use `guide = \"none\"` instead.\nn <- 100\nmb <- microbenchmark(mvtnorm::dmvnorm(matrix(1.96, nrow = n, ncol = 2)),\n                     mvnpdf(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE),\n                     times=100L)\nmb## Unit: microseconds\n##                                                       expr     min      lq\n##         mvtnorm::dmvnorm(matrix(1.96, nrow = n, ncol = 2))  76.921 121.900\n##  mvnpdf(x = matrix(1.96, nrow = 2, ncol = n), Log = FALSE) 714.938 965.764\n##      mean    median       uq      max neval cld\n##   252.237  185.1075  340.017  709.690   100  a \n##  1502.635 1372.2070 1880.828 3639.201   100   b## Warning: It is deprecated to specify `guide = FALSE` to remove a guide. Please\n## use `guide = \"none\"` instead."},{"path":"profiler-son-code.html","id":"profiler-son-code","chapter":"4 Profiler son code","heading":"4 Profiler son code","text":"parle de profiling en anglais. Il s’agit de déterminer ce qui prend\ndu temps dans un code. Le étant une fois trouvé le bloc de code qui prend\nle plus de temps dans l’exécution d’optimiser uniquement cette brique.Pour obtenir un profiling du code ci-dessous, sélectionner les lignes de code\nd’intérêt et aller dans le menu “Profile” puis “Profile Selected Lines” (ou\nCtrl+Alt+Shift P).OK, get ! Concaténer un vecteur au fur et à mesure dans une boucle\nn’est vraiment pas une bonne idée.","code":"\nn <- 10e4\npdfval <- mvnpdf(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE)"},{"path":"profiler-son-code.html","id":"comparaison-avec-une-version-plus-habile-de-mnvpdf","chapter":"4 Profiler son code","heading":"4.1 Comparaison avec une version plus habile de mnvpdf()","text":"Considérons une nouvelle version de mvnpdf(), appelée mvnpdfsmart().\nTélécharger le\nfichier puis\nl’inclure dans le package.Profiler la commande suivante :effectivement résolu le problème et apprend maintenant de manière plus\nfine ce qui prend du temps dans notre fonction.Pour confirmer que mvnpdfsmart() est effectivement bien plus rapide que\nmvnpdf() peut re-faire une comparaison avec microbenchmark() :Et peut également voir si devient compétitif avec dmvnorm() :Il y encore du travail…","code":"\nn <- 10e4\npdfval <- mvnpdfsmart(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE)\nn <- 1000\nmb <- microbenchmark(mvnpdf(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE),\n                     mvnpdfsmart(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE),\n                     times=100L)\nmb## Unit: milliseconds\n##                                                            expr      min\n##       mvnpdf(x = matrix(1.96, nrow = 2, ncol = n), Log = FALSE) 4.790313\n##  mvnpdfsmart(x = matrix(1.96, nrow = 2, ncol = n), Log = FALSE) 3.470507\n##        lq     mean   median       uq      max neval cld\n##  5.023039 7.941819 5.951086 7.447729 38.57898   100   b\n##  3.736230 4.654822 3.817214 4.203385 13.84234   100  a## Warning: It is deprecated to specify `guide = FALSE` to remove a guide. Please\n## use `guide = \"none\"` instead.\nn <- 1000\nmb <- microbenchmark(mvtnorm::dmvnorm(matrix(1.96, nrow = n, ncol = 2)),\n                     mvnpdf(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE),\n                     mvnpdfsmart(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE),\n                     times=100L)\nmb## Unit: microseconds\n##                                                            expr      min\n##              mvtnorm::dmvnorm(matrix(1.96, nrow = n, ncol = 2))   77.999\n##       mvnpdf(x = matrix(1.96, nrow = 2, ncol = n), Log = FALSE) 4811.461\n##  mvnpdfsmart(x = matrix(1.96, nrow = 2, ncol = n), Log = FALSE) 3690.870\n##        lq      mean    median         uq       max neval cld\n##   113.547   226.023  153.2655   231.1895  1132.803   100 a  \n##  5637.466 10635.644 6557.2955 14264.7220 52341.565   100   c\n##  4137.653  7158.134 4897.3990  9816.1835 43621.789   100  b## Warning: It is deprecated to specify `guide = FALSE` to remove a guide. Please\n## use `guide = \"none\"` instead."},{"path":"profiler-son-code.html","id":"comparaison-avec-une-version-optimisée-dans-r","chapter":"4 Profiler son code","heading":"4.2 Comparaison avec une version optimisée dans R","text":"Boris est arrivée après plusieurs recherches et tests à une\nversion optimisée\navec les outils de R.Inclure la fonction mvnpdfoptim() dans le package, puis profiler cette\nfonction :Et un petit microbenchmark() :Pour finir peut profiler la fonction dmvnorm() :","code":"\nn <- 10e4\npdfval <- mvnpdfoptim(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE)\nn <- 1000\nmb <- microbenchmark(mvtnorm::dmvnorm(matrix(1.96, nrow = n, ncol = 2)),\n                     mvnpdf(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE),\n                     mvnpdfsmart(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE),\n                     mvnpdfoptim(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE),\n                     times=100L)\nmb## Unit: microseconds\n##                                                            expr      min\n##              mvtnorm::dmvnorm(matrix(1.96, nrow = n, ncol = 2))   67.308\n##       mvnpdf(x = matrix(1.96, nrow = 2, ncol = n), Log = FALSE) 4752.076\n##  mvnpdfsmart(x = matrix(1.96, nrow = 2, ncol = n), Log = FALSE) 3542.849\n##  mvnpdfoptim(x = matrix(1.96, nrow = 2, ncol = n), Log = FALSE) 2721.043\n##        lq      mean    median       uq       max neval  cld\n##    85.947  121.2509  100.9385  120.221   745.734   100 a   \n##  4984.280 7219.4899 5279.5135 6890.208 28675.782   100    d\n##  3706.249 4697.9993 3771.3055 4015.110 16556.949   100   c \n##  2826.413 3601.8965 2946.8220 3213.134 12935.049   100  b## Warning: It is deprecated to specify `guide = FALSE` to remove a guide. Please\n## use `guide = \"none\"` instead.\nn <- 10e5\npdfval <- mvtnorm::dmvnorm(matrix(1.96, nrow = n, ncol = 2))"},{"path":"rcpp-ou-comment-intégrer-facilement-du-code-cdans-un-package.html","id":"rcpp-ou-comment-intégrer-facilement-du-code-cdans-un-package","chapter":"5 Rcpp ou comment intégrer facilement du code C++dans un package ","heading":"5 Rcpp ou comment intégrer facilement du code C++dans un package ","text":"Rcpp (R-C-Plus-Plus) est un package qui facilite l’interface entre C++ et .  est un langage\ninterprété, ce qui facilite un certain nombre de choses (notamment nous donne accès à la console\ndans laquelle peut évaluer du code à la volée). Néanmoins, cette facilité d’utilisation se\ncompense entre autre par des temps de calcul supérieurs à ceux de langages de plus bas niveau,\ntels que C, Fortran et C++ (mais qui nécessitent eux une compilation).dirigera le lecteur curieux vers le livre en ligne\nRcpp everyone de Masaki E. Tsuda, qui\nconstitue une ressource très complète pour comprendre l’utilisation de Rcpp en plus de\nl’introduction que l’peut trouver dans le livre Advanced R d’Hadley\nWickham.","code":""},{"path":"rcpp-ou-comment-intégrer-facilement-du-code-cdans-un-package.html","id":"première-fonction-en-rcpp","chapter":"5 Rcpp ou comment intégrer facilement du code C++dans un package ","heading":"5.1 Première fonction en Rcpp","text":"vous de jouer !Afin de rendre votre package prêt pour l’utilisation avec Rcpp, commencez par executer la commande\nsuivante :Constatez les changements apportésConstatez les changements apportésil faut également ajouter les 2 commentaires roxygen suivants dans la page d’aide du\npackage dans son ensemble :il faut également ajouter les 2 commentaires roxygen suivants dans la page d’aide du\npackage dans son ensemble :Nous allons maintenant créer une première fonction en Rcpp permettant d’inverser une matrice.\nPour cela, nous allons nous appuyer sur la library C++ Armadillo.\nIl s’agit d’une library d’algèbre linéaire moderne et simple, hautement optimisée, et interfacée\navec  via le package RcppArmadillo.C++ n’est pas un langage très différent de . Les principales différences qui nous concernent :C++est très efficaces pour le boucles (y compris les boucles emboîtées). Attention :\nil y souvent un sens qui est plus rapide que l’autre (ceci est dû à la manière dont C++ attribue\net parcours la mémoire).C++est très efficaces pour le boucles (y compris les boucles emboîtées). Attention :\nil y souvent un sens qui est plus rapide que l’autre (ceci est dû à la manière dont C++ attribue\net parcours la mémoire).Chaque commande doit se terminer par un point virgule ‘;’Chaque commande doit se terminer par un point virgule ‘;’C++est un langage typé : il faut déclarer le type de chaque variable avant de pouvoir\nl’utiliser.C++est un langage typé : il faut déclarer le type de chaque variable avant de pouvoir\nl’utiliser.vous de jouer !Créez un nouveau fichier C++ depuis RStudio (via le menu File > New File > C++ File),\net enregistrez le dans le dossier src. Prenez le temps de le lire et essayez de comprendre\nchaque ligne.Créez un nouveau fichier C++ depuis RStudio (via le menu File > New File > C++ File),\net enregistrez le dans le dossier src. Prenez le temps de le lire et essayez de comprendre\nchaque ligne.Compilez et chargez votre package (via le bouton “Install Restart”) et essayez d’utiliser\nla fonction timesTwo() depuis la console.Compilez et chargez votre package (via le bouton “Install Restart”) et essayez d’utiliser\nla fonction timesTwo() depuis la console.Installez le package RcppArmadillo, et n’oubliez pas de faire les ajouts nécessaires dans\nDESCRIPTION (cf. Rcpp précédement - vous pouvez expérimentez avec la fonction\nRcppArmadillo::RcppArmadillo.package.skeleton() qui le désavantage de créer beaucoup de fichiers\ninutiles)Installez le package RcppArmadillo, et n’oubliez pas de faire les ajouts nécessaires dans\nDESCRIPTION (cf. Rcpp précédement - vous pouvez expérimentez avec la fonction\nRcppArmadillo::RcppArmadillo.package.skeleton() qui le désavantage de créer beaucoup de fichiers\ninutiles)À l’aide de la documentation des packages Rcpp\net RcppArmadillo de celle de la\nlibrary Armadillo, tentez d’écrire une courte fonction\ninvC en C++ calculant l’inverse d’une matrice.À l’aide de la documentation des packages Rcpp\net RcppArmadillo de celle de la\nlibrary Armadillo, tentez d’écrire une courte fonction\ninvC en C++ calculant l’inverse d’une matrice.Lorsque vous avez réussi à compiler votre fonction invC et qu’elle est accèssible depuis \ncréer une fonction mvnpdf_invC() à partir de l’implémentation de mvnpdfsmart en remplaçant\nuniquement les calculs d’inverse matriciel par un appel à invC.Lorsque vous avez réussi à compiler votre fonction invC et qu’elle est accèssible depuis \ncréer une fonction mvnpdf_invC() à partir de l’implémentation de mvnpdfsmart en remplaçant\nuniquement les calculs d’inverse matriciel par un appel à invC.Evaluer le gain en performance de cette nouvelle implémentation mvnpdf_invCEvaluer le gain en performance de cette nouvelle implémentation mvnpdf_invC","code":"\ndevtools::use_rcpp()\n#' @useDynLib mypkgr\n#' @importFrom Rcpp sourceCpp, .registration = TRUE\nNULL\nn <- 1000\nmb <- microbenchmark(mvtnorm::dmvnorm(matrix(1.96, nrow = n, ncol = 2)),\n                     mvnpdf(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE),\n                     mvnpdfsmart(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE),\n                     mvnpdfoptim(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE),\n                     mvnpdf_invC(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE),\n                     times=100L)\nmb## Unit: microseconds\n##                                                            expr      min\n##              mvtnorm::dmvnorm(matrix(1.96, nrow = n, ncol = 2))   71.603\n##       mvnpdf(x = matrix(1.96, nrow = 2, ncol = n), Log = FALSE) 4394.718\n##  mvnpdfsmart(x = matrix(1.96, nrow = 2, ncol = n), Log = FALSE) 3055.171\n##  mvnpdfoptim(x = matrix(1.96, nrow = 2, ncol = n), Log = FALSE) 2458.297\n##  mvnpdf_invC(x = matrix(1.96, nrow = 2, ncol = n), Log = FALSE) 3118.366\n##         lq      mean    median       uq       max neval cld\n##    88.6125  131.0086  106.0255  129.659   732.902   100 a  \n##  5035.0090 6673.3526 5262.9320 6308.673 34971.465   100   c\n##  3790.1275 4599.6529 3920.4310 4241.278 16861.129   100  b \n##  2893.1235 3942.1172 3062.0920 3566.399 15614.461   100  b \n##  3753.6965 4687.4476 3889.6020 4412.845 13158.539   100  b## Warning: It is deprecated to specify `guide = FALSE` to remove a guide. Please\n## use `guide = \"none\"` instead.\nprofvis::profvis(mvnpdfoptim(x=matrix(1.96, \n    nrow = 2, ncol = 1000), Log=FALSE))\nprofvis::profvis(mvnpdfoptim(x=matrix(1.96, \n    nrow = 100, ncol = 1000), Log=FALSE))"},{"path":"rcpp-ou-comment-intégrer-facilement-du-code-cdans-un-package.html","id":"optimisation-grâce-à-c","chapter":"5 Rcpp ou comment intégrer facilement du code C++dans un package ","heading":"5.2 Optimisation grâce à C++","text":"En règle générale, ne gagne pas beaucoup en temps de calcul en remplaçant une fonction \noptimisée par une fonction en C++. En effet, la plupart des fonctions de base de  s’appuie en\nréalité déjà sur des routines C ou Fortran bien optimisée. Le gain se limite alors simplement\nà la suppression des vérifications des arguments et de la gestion des différents types.vous de jouer !À partir de mvnpdfsmart, proposez une implémentation completement en C++ du calcul\nde densité de la loi Normale multivariée mvnpdfC().À partir de mvnpdfsmart, proposez une implémentation completement en C++ du calcul\nde densité de la loi Normale multivariée mvnpdfC().Evaluer le gain en performance de cette nouvelle implémentation mvnpdf_invCEvaluer le gain en performance de cette nouvelle implémentation mvnpdf_invCVous pouvez télécharger notre proposition de mvnpdfC.cpp ici.À noter que vous pouvez utiliser des fonctions Rcpp en dehors de l’architecture\nd’un package grâce à la fonction Rcpp::sourceCpp(). Mais comme nous avons\nqu’il est préférable de gérer tous ces code sous la forme de package, il est\npeu probable que vous en ayez besoin !","code":"\nn <- 1000\nmb <- microbenchmark(mvtnorm::dmvnorm(matrix(1.96, nrow = n, ncol = 2)),\n                     mvnpdf(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE),\n                     mvnpdfsmart(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE),\n                     mvnpdfoptim(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE),\n                     mvnpdf_invC(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE),\n                     mvnpdfC(x=matrix(1.96, nrow = 2, ncol = n), mean = rep(0, 2), varcovM = diag(2), Log=FALSE),\n                     times=100L)\nmb## Unit: microseconds\n##                                                                                                  expr\n##                                                    mvtnorm::dmvnorm(matrix(1.96, nrow = n, ncol = 2))\n##                                             mvnpdf(x = matrix(1.96, nrow = 2, ncol = n), Log = FALSE)\n##                                        mvnpdfsmart(x = matrix(1.96, nrow = 2, ncol = n), Log = FALSE)\n##                                        mvnpdfoptim(x = matrix(1.96, nrow = 2, ncol = n), Log = FALSE)\n##                                        mvnpdf_invC(x = matrix(1.96, nrow = 2, ncol = n), Log = FALSE)\n##  mvnpdfC(x = matrix(1.96, nrow = 2, ncol = n), mean = rep(0, 2),      varcovM = diag(2), Log = FALSE)\n##       min        lq      mean    median       uq       max neval  cld\n##    70.314   90.8555  118.7912  111.3245  128.202   403.318   100 a   \n##  4442.162 5034.0980 5806.1428 5218.3360 5723.780 15313.112   100    d\n##  3307.198 3782.3440 4830.3060 3919.2540 4222.309 42014.009   100   c \n##  2351.875 2831.7825 3329.2880 2997.8205 3220.057  9009.724   100  b  \n##  3218.508 3744.4270 4279.3562 3887.2750 4050.761 13810.887   100   c \n##    46.554   61.7370   87.4028   70.0115   77.825  1399.844   100 a## Warning: It is deprecated to specify `guide = FALSE` to remove a guide. Please\n## use `guide = \"none\"` instead."},{"path":"rcpp-ou-comment-intégrer-facilement-du-code-cdans-un-package.html","id":"annexe-5.1-loptimisation-prématurée-nest-pas-une-bonne-idée","chapter":"5 Rcpp ou comment intégrer facilement du code C++dans un package ","heading":"5.3 Annexe 5.1 : l’optimisation prématurée n’est pas une bonne idée","text":"Chambers, Software Data Analysis: Programming R, Springer, 2008 :Including additional C code serious step, added dangers\noften substantial amount programming debugging required.\ngood reason.","code":""},{"path":"parallélisation-du-code.html","id":"parallélisation-du-code","chapter":"6 Parallélisation du code ","heading":"6 Parallélisation du code ","text":"","code":""},{"path":"parallélisation-du-code.html","id":"introduction-à-lexecution-parallèle-sous","chapter":"6 Parallélisation du code ","heading":"6.1 Introduction à l’execution parallèle sous ","text":"En dehors de l’optimisation du code et des algorithmes, une autre façon\nd’obtenir un code performant est de tirer profit des architectures parallèles\ndes ordinateurs modernes. Il s’agit alors de paralléliser son code afin de\nfaire des opérations simultanées sur des parties distinctes d’un même problème,\nen utilisant différent cœurs de calcul. ne réduit pas le temps de calcul\ntotal nécessaire, mais l’ensemble des opérations s’exécute plus rapidement.Il existe un nombre non négligeable d’algorithmes qui sont d’un “parallélisme\nembarrassant”, c’est-à-dire dont les calculs peuvent se décomposer en plusieurs\nsous-calculs indépendants. En statistique, il est ainsi souvent facile et direct\nde paralléliser selon les différentes observations ou selon les différentes\ndimensions. Typiquement, il s’agit d’opérations que l’peut écrire sous la\nforme de boucle dont les opérations sont indépendantes d’une itération de la\nboucle à l’autre.Les opérations nécessaires pour l’établissement d’un code parallèle sont les suivantes :Démarrer \\(m\\) processus “travailleurs” (.e. cœurs de calcul) et les initialiserDémarrer \\(m\\) processus “travailleurs” (.e. cœurs de calcul) et les initialiserEnvoyer les fonctions et données nécessaires pour chaque tache aux travailleursEnvoyer les fonctions et données nécessaires pour chaque tache aux travailleursSéparer les taches en \\(m\\) opérations d’envergure similaire et les envoyer aux travailleursSéparer les taches en \\(m\\) opérations d’envergure similaire et les envoyer aux travailleursAttendre que tous les travailleurs aient terminer leurs calculs et obtenir leurs résultatsAttendre que tous les travailleurs aient terminer leurs calculs et obtenir leurs résultatsRassembler les résultats des différents travailleursRassembler les résultats des différents travailleursArrêter les processus travailleursArrêter les processus travailleursSelon les plateformes, plusieurs protocoles de communications sont disponibles\nentre les cœurs. Sous les systèmes UNIX, le protocole Fork est le plus\nutilisé, mais il n’est pas disponible sous Windows où utilise\npréférentiellement le protocole PSOCK. Enfin, pour les architecture de calcul\ndistribuée où les cœurs ne se trouvent pas nécessairement sur le même processeur\nphysique, utilise généralement le protocole MPI. L’avantage des packages\nfuture et future.apply est que le même code pourra être exécuté quelque soit\nla configuration matérielle.Il existe un nombre important de packages et d’initiatives permettant de faire\ndu calcul en R. Depuis R 2.14.0, le package\nparallel\nest inclus directement dans  et permet de démarrer et d’arrêter un “cluster”\nde plusieurs processus travailleur (étape 1 et 6). En plus du package\nparallel, va donc utiliser le package future qui permet de gérer les\nprocessus travailleurs et la communication et l’articulation avec le package\nfuture.applyqui permet lui de gérer le dialogue avec les travailleurs (envois,\nréception et rassemblement des résultats - étapes 2, 3, 4 et 5).","code":""},{"path":"parallélisation-du-code.html","id":"première-fonction-parallèle-en","chapter":"6 Parallélisation du code ","heading":"6.2 Première fonction parallèle en ","text":"À vous de jouer !Commencez par écrire une fonction simple qui calcule le logarithme de \\(n\\)\nnombres:Déterminez combien de coeurs sont disponibles sur votre marchine grâce à\nla fonction future::availableCores().Déterminez combien de coeurs sont disponibles sur votre marchine grâce à\nla fonction future::availableCores().À l’aide de la fonction future::plan(multisession(workers = XX)),\ndéclarez un “plan” de calculs parallèles sur votre ordinateur (en prenant garde\nà laisser un coeur disponible pour traiter les autres processus).À l’aide de la fonction future::plan(multisession(workers = XX)),\ndéclarez un “plan” de calculs parallèles sur votre ordinateur (en prenant garde\nà laisser un coeur disponible pour traiter les autres processus).À l’aide d’une fonction de type apply future.apply::future_*apply(),\ncalculez le log des \\(n\\) nombres en parallèle et concaténez les résultats dans un\nvecteur.À l’aide d’une fonction de type apply future.apply::future_*apply(),\ncalculez le log des \\(n\\) nombres en parallèle et concaténez les résultats dans un\nvecteur.Comparez le temps d’éxecution avec celui d’une fonction séquentielle\nsur les 100 premiers entiers, grâce à la commande :microbenchmark(log_par(1:100), log_seq(1:100), times=10)Comparez le temps d’éxecution avec celui d’une fonction séquentielle\nsur les 100 premiers entiers, grâce à la commande :microbenchmark(log_par(1:100), log_seq(1:100), times=10)La version parallèle tourne beaucoup plus lentement… Car en fait, si les\ntâches individuelles sont trop rapides,  va passer plus de temps à\ncommuniquer avec les cœurs, qu’à faire les calculs effectifs.Il faut qu’une itération de la boucle soit relativement longue pour que le\ncalcul parallèle apporte un gain en temps de calcul !En augmentant \\(n\\), observe une réduction de la différence entre les 2\nimplémentations (le temps de calcul en parallèle augmente très lentement comparé\nà l’augmentation de celui de la fonction séquentielle).NB : les itérateurs d’itertools sont très performants mais ne peuvent\nservir que lorsque le code à l’intérieur de future_*apply() est vectorisé (il\nest toujours possible de vectoriser le code à l’intérieur, par exemple avec une\nfonction de type apply). Ils minimisent le nombre de communication entre les\ncoeurs.","code":"\nlibrary(microbenchmark)\nlibrary(future.apply)\n\nlog_seq <- function(x){\n  # try this yourself (spoiler alert: it is quite long...):\n  # res <- numeric(length(x))\n  # for(i in 1:length(x)){\n  #   res[i] <- log(x[i])\n  # }\n  # return(res)\n  return(log(x))\n}\n\nlog_par <- function(x){\n  res <- future_sapply(1:length(x), FUN = function(i) {\n    log(x[i])\n  })\n  return(res)\n}\n\nplan(multisession(workers = 3))\nmb <- microbenchmark(log_par(1:100), log_seq(1:100), times = 50)"},{"path":"parallélisation-du-code.html","id":"parallélisation-efficace","chapter":"6 Parallélisation du code ","heading":"6.3 Parallélisation efficace","text":"va maintenant se pencher sur un autre cas d’utilisation. Imaginons que l’\nait un grand tableau de données de taille comportant 10 observations pour 100\n000 variables (e.g. des mesures de génomique), et que l’veuille calculer la\nmédiane pour chacune de ces variables.Pour un utilisateur averti de , une telle opération se programme facilement\nà l’aide de la fonction apply :En réalité, une boucle n’est pas plus lente à condition d’être bien\nprogrammée :À vous de jouer !\nEssayez d’améliorer encore ce temps de calcul en parallélisant :Parallélisez le calcul de la médiane de chacune des 100 000 variables.\nObserve-t-un gain en temps de calcul ?Parallélisez le calcul de la médiane de chacune des 100 000 variables.\nObserve-t-un gain en temps de calcul ?Proposez une implémentation alternative grâce à la fonction\nitertools::isplitIndices() qui permet de séparer vos données (les \\(n\\) nombres)\nen autant de groupes que vous avez de coeurs. Comparez à nouveau les temps de\ncalcul.Proposez une implémentation alternative grâce à la fonction\nitertools::isplitIndices() qui permet de séparer vos données (les \\(n\\) nombres)\nen autant de groupes que vous avez de coeurs. Comparez à nouveau les temps de\ncalcul.","code":"\nx <- matrix(rnorm(1e6), nrow = 10)\ndim(x)## [1]     10 100000\ncolmedian_apply <- function(x){\n  return(apply(x, 2, median))\n}\nsystem.time(colmedian_apply(x))## utilisateur     système      écoulé \n##       2.871       0.008       2.883\ncolmedian_for <- function(x){\n  ans <- rep(0, ncol(x)) \n  for (i in 1:ncol(x)) {\n    ans[i] <- median(x[, i]) \n  }\n  return(ans)\n}\nsystem.time(colmedian_for(x))## utilisateur     système      écoulé \n##       2.895       0.010       2.917\ncolmedian_par <- function(x){\n  res <- future_sapply(1:ncol(x), FUN = function(i) {\n          median(x[, i])\n    })\n  return(res)\n}\nplan(multisession(workers = 3))\nsystem.time(colmedian_par(x))## utilisateur     système      écoulé \n##       0.101       0.019       1.439\ncolmedian_parIter <- function(x, ncores = 1){\n  iter <- itertools::isplitIndices(n = ncol(x), chunks = ncores)\n  res <- future_sapply(iter, FUN = function(i) {\n          apply(x[, i], 2, median)\n    })\n  return(unlist(res))\n}\nsystem.time(colmedian_parIter(x, ncores = 3))## utilisateur     système      écoulé \n##       0.082       0.017       1.245\nmb <- microbenchmark(colmedian_apply(x), \n                     colmedian_for(x),\n                     colmedian_par(x),\n                     colmedian_parIter(x, ncores = 3), times = 10)\nmb## Unit: milliseconds\n##                              expr       min       lq     mean   median       uq\n##                colmedian_apply(x) 2508.9098 2629.735 2689.872 2691.283 2783.711\n##                  colmedian_for(x) 2549.3103 2574.686 2758.920 2674.481 2740.282\n##                  colmedian_par(x) 1092.2788 1123.261 1154.978 1133.733 1143.486\n##  colmedian_parIter(x, ncores = 3)  993.0038 1045.915 1129.355 1081.597 1111.276\n##       max neval cld\n##  2796.538    10   b\n##  3612.499    10   b\n##  1362.110    10  a \n##  1636.029    10  a"},{"path":"parallélisation-du-code.html","id":"les-itérateurs","chapter":"6 Parallélisation du code ","heading":"6.3.1 Les itérateurs","text":"Le package itertools permet de séparer facilement des données ou des\ntaches (étape 3) tout en minimisant les communications avec les différents\ntravailleurs. Il s’appuie sur une implémentation des itérateurs en .\nSon utilisation nécessite néanmoins de vectoriser le code à l’intérieur de\nfuture_*apply(). Expérimentez avec le petit code ci-dessous :","code":"\nmyiter <- itertools::isplitIndices(n = 30, chunks = 3)\n\n# Une première fois\niterators::nextElem(myiter)##  [1]  1  2  3  4  5  6  7  8  9 10\n# Une deuxième fois... Oh ?!\niterators::nextElem(myiter)##  [1] 11 12 13 14 15 16 17 18 19 20\n# Encore !\niterators::nextElem(myiter)##  [1] 21 22 23 24 25 26 27 28 29 30\n# Encore ?\niterators::nextElem(myiter)## Error: StopIteration"},{"path":"parallélisation-du-code.html","id":"les-autres-plans-de-calculs-parallèle","chapter":"6 Parallélisation du code ","heading":"6.3.2 Les autres “plans” de calculs parallèle","text":"Pour exécuter votre code (exactement le même code, c’est un des avantages\ndu packages de la famille future*), vous devez régler un “plan” de calculs :sur un ordinateur (ou un unique serveur de calcul) sous Unix (Linux, Mac OS),\nvous pouvez utiliser plan(multicore(workers = XX)) qui est souvent plus\nperformant. Le plan multisession fonctionne toujours.sur un ordinateur (ou un unique serveur de calcul) sous Unix (Linux, Mac OS),\nvous pouvez utiliser plan(multicore(workers = XX)) qui est souvent plus\nperformant. Le plan multisession fonctionne toujours.sur un cluster de calculs (type Avakas à Bordeaux), nous renvoyons au package\nfuture.batchtoolssur un cluster de calculs (type Avakas à Bordeaux), nous renvoyons au package\nfuture.batchtools","code":""},{"path":"parallélisation-du-code.html","id":"parallélisation-dans-notre-exemple-fil-rouge","chapter":"6 Parallélisation du code ","heading":"6.4 Parallélisation dans notre exemple fil rouge","text":"À vous de jouer !À partir de la fonction mvnpdfoptim() et/ou mvnpdfsmart(), proposez\nune implémentation parallélisant les calculs sur les observations (colonnes de \\(x\\))À partir de la fonction mvnpdfoptim() et/ou mvnpdfsmart(), proposez\nune implémentation parallélisant les calculs sur les observations (colonnes de \\(x\\))Comparez les temps de calcul sur 10 000 observationsComparez les temps de calcul sur 10 000 observations","code":"\nplan(multisession(workers = 3))\nn <- 10000\nmb <- microbenchmark::microbenchmark(\n  mvtnorm::dmvnorm(matrix(1.96, nrow = n, ncol = 2)),\n  mypkgr::mvnpdfoptim(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE),\n  mypkgr::mvnpdfoptim_par(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE),\n  mypkgr::mvnpdfoptim_parIter(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE, ncores = 3),\n  times=20L)\nmb## Unit: microseconds\n##                                                                                             expr\n##                                               mvtnorm::dmvnorm(matrix(1.96, nrow = n, ncol = 2))\n##                           mypkgr::mvnpdfoptim(x = matrix(1.96, nrow = 2, ncol = n), Log = FALSE)\n##                  mypkgr::mvnpdfoptim_par(x = matrix(1.96, nrow = 2, ncol = n),      Log = FALSE)\n##  mypkgr::mvnpdfoptim_parIter(x = matrix(1.96, nrow = 2, ncol = n),      Log = FALSE, ncores = 3)\n##        min         lq       mean     median         uq       max neval cld\n##    300.519   344.0155   362.6347   352.9305   392.7385    447.60    20  a \n##  24144.586 27844.8270 29340.4425 28354.5550 29700.8440  37591.64    20  ab\n##  21117.246 24406.5590 25520.3099 25217.5930 26919.3365  28695.41    20  ab\n##  20026.677 22529.1105 40802.1316 25208.0950 26377.1595 349567.61    20   b"},{"path":"parallélisation-du-code.html","id":"conclusion","chapter":"6 Parallélisation du code ","heading":"6.5 Conclusion","text":"La parallélisation permet de gagner du temps, mais il faut d’abord bien\noptimiser son code. Quand parallélise un code, le gain sur la durée\nd’exécution dépend avant tout du ratio entre le temps de communication et le\ntemps de calcul effectif pour chaque tache.","code":""},{"path":"miscélanées.html","id":"miscélanées","chapter":"7 Miscélanées","heading":"7 Miscélanées","text":"","code":""},{"path":"miscélanées.html","id":"debugging-avec-browser","chapter":"7 Miscélanées","heading":"7.1 Debugging avec browser()","text":"","code":""},{"path":"miscélanées.html","id":"attach","chapter":"7 Miscélanées","heading":"7.2 attach","text":"","code":""},{"path":"miscélanées.html","id":"gestion-mémoire","chapter":"7 Miscélanées","heading":"7.3 gestion mémoire","text":"","code":""},{"path":"miscélanées.html","id":"copies-et-variables-localesglobales-dans-les-fonctions","chapter":"7 Miscélanées","heading":"7.4 copies et variables locales/globales dans les fonctions","text":"","code":""},{"path":"miscélanées.html","id":"naming","chapter":"7 Miscélanées","heading":"7.5 naming","text":"","code":""},{"path":"miscélanées.html","id":"gpplot2","chapter":"7 Miscélanées","heading":"7.6 gpplot2","text":"","code":""},{"path":"take-home-message.html","id":"take-home-message","chapter":"8 Take Home message","heading":"8 Take Home message","text":"MAKE PACKAGESMAKE PACKAGESuse git, least locally yourselfuse git, least locally yourselfif needed (.e. optimization  code ), afraid using Rcpp /parallelizing tour codeif needed (.e. optimization  code ), afraid using Rcpp /parallelizing tour code","code":""},{"path":"further-reading.html","id":"further-reading","chapter":"Further reading","heading":"Further reading","text":"Hadley Wickham’s online books truly excellent contain lot supplementary informattion covered training:\nwebsite writing packages R packages.\nwebsite Advanced R everything regarding optimization, Rcpp, parallel computing.\nwebsite R Data Science also quite comprehensive includes chapters data management , also structures , modeling, well elements graphics Rmarkdown.\nHadley Wickham’s online books truly excellent contain lot supplementary informattion covered training:website writing packages R packages.website writing packages R packages.website Advanced R everything regarding optimization, Rcpp, parallel computing.website Advanced R everything regarding optimization, Rcpp, parallel computing.website R Data Science also quite comprehensive includes chapters data management , also structures , modeling, well elements graphics Rmarkdown.website R Data Science also quite comprehensive includes chapters data management , also structures , modeling, well elements graphics Rmarkdown.online book Rcpp everyone Masaki E. Tsuda also good.online book Rcpp everyone Masaki E. Tsuda also good.","code":""}]
