
# Version control with `git` and *GitHub* 

We are interested here in the solutions offered by *RStudio* and *GitHub* for hosting and version control of projects. THis allows to monitor changes history, to help collaborative development and to facilitate continuous integration.

## Principles of version control

The principle of version control is to record the successive changes made to files (especially `.R` files in our case).

*RStudio* offers 2 integrated solutions for version control:

  - `git`
  
  - `svn`




### `git`

`git` is a version control software (i.e. a tool that will record the history of successive changes to your code and allow you to share these changes with other people). `git` is a command line program, and it is not necessarily very intuitive to use. 

`git` works as follows: on a server in the cloud, an **updated** version of the code is available. At any time it is possible to access this version of the code online. Each contributor can download this last **updated** version (in an action called *pull*), 
before editing it locally. Once changes are made locally, the 
contributor can then update the online version of the code, so that his changes become available to everyone (in an action called *push*).

**NB:** `git` was designed for lightweight files (such as text files) and is far from being optimized for heavy and/or compressed files (e.g. `.RData` files).


### `subversion`

`subversion` is the other solution available in *RStudio*. It works in a similar way to git, but with less functionalities that we won't detail here (the major difference is that all 
contributors work simultaneously on the same version of the code).


## Use `git` locally within *RStudio*

> `r emoji::emoji("point_right")` ***Your turn !***  
> 
  1. Start by enabling `git` from the "Git/SVN" tab of "Project Options" located in the "Tools" menu and follow the instructions. You can also use `usethis::use_git()`.
>  
  2. From the "Git" tab that now appears next to the "Build" tab, 
  register the current state of your package by making your first commit:
 >     
      - 2a. Select the files to track (do not select the `.Rproj` file)
 >     
      - 2b. write an informative message (for your collaborators -- this includes your future self)
 >     
      - 2c. click on "Commit" >
>     
  3. Add a "*.Rproj" line to the ".gitignore" file and make a new commit
>  
  4. Visualize the changes and their history using the visualization tools 
  "Diff" and "History" tools accessible from the "Git" tab
  
  
### Good *commit* practices

Ideally, each commit should solve only one problem. It should fix it in its entirety (be **complete**), and contain only changes related to that very problem (be **minimal**). It is especially useful to write **informative** commit messages (be kind and help your collaborators, which includes your **future self**). You should also be concise, and describe the reasons for the changes rather than the the changes themselves (visible in the *Diff*). **NB:** it is sometimes difficult to follow these guidelines to the letter, and they are merely an ideal guide. They certainly should not prevent you from should from regularly making *commits*. 

On the other hand, the temptation to have a *"clean" and tidy* change-history is natural, but it is a source of unnecessary problems. It contradicts the traceability goal of version control. Since code development is generally a complex, messy, and non-linear intellectual process, it is normal that the recording of changes reflects this path. In practice, your future self will be the first user of your change history, so the priority is to make it easier for you in the future when solving bugs or extending functionality.




## GitHub

[GitHub](https://github.com/) is a website offering an online code hosting solution, and is based on `git`. There are many alternative websites and services (gitlab, bitbucket, ...) allowing to host code and also based on `git`. GitHub is very popular in the `r fontawesome::fa("r-project")` community, and is relatively easy to use, even for a novice user.

Advantages of using GitHub:
 
  - a simple and user-friendly graphical interface to track the history of changes to your code
  
  - the latest development version of your code is available online and you can reference it (you can even reference a specific commit number to freeze a specific version of the code)
  
  - users have a clear and transparent channel to report bugs/difficulties
  
  - it greatly facilitates collaborative development
  
  
### Upload one's package `r fontawesome::fa("r-project")` onto GitHub

> `r emoji::emoji("point_right")` ***Your turn !*** 
>
  1. Go to [https://github.com/](https://github.com/) and create a GitHub account (if you hesitate, a common convention is to use your *firstnamelastname* as username)
>  
  2. Use `usethis::use_github()` and follow the instructions.
>  
  3. Add a "README.Rmd" file to your package in order to have a nice home page on GitHub 
  page on GitHub:
>  
    - 3a. In *RStudio*, run the command `usethis::use_readme_rmd()`
>  
    - 3b. using the "Diff" tool in the "Git" tab of *RStudio*, review the changes made by the previous command
 >   
    - 3c. edit the created "README.Rmd" file, then create the corresponding README.md  file by running `knitr` (click on the wool ball "Knit" at the top left in *RStudio*), before making a 3^rd^ commit containing these changes
>    
    - 3d. At this point, if you visit your directory page on GitHub, your 3^rd^ commit does not appear for the moment. You have to synchronize the online GitHub directory with your local folder. To do this, you have to click on "Push" from the "Git" tab. Now, the changes of this 3^rd^ commit should be visible online on GitHub.
      
    
    

## Collaborative code production

`git` and GitHub are particularly useful and efficient when several people collaborate to develop code together. Indeed, everyone can *pull* and *push* successive changes to the code, simultaneously, while endusing to always be working on the latest version of the code. We will see different concepts useful in the case of such a collaborative work.

> `r emoji::emoji("point_right")` ***Your turn !*** 
>
1. By pairing-up with another participant, you will each add your new buddy as a "collaborator" to your GitHub directory from the **"Settings" tab on GitHub**.
>
  2. A few moments later, the added collaborator receives an email inviting him to accept the addition (check your spam folder). Click on the link and accept.
>
  3. In *RStudio*, create a new project form `git` using the url of your buddy's project.
   
### *Branches*

One of the most useful features of git is *branches*. This allows you to make important changes in the changes in the code without disrupting the current operation. It is particularly useful to explore a development path that you don't know if it will be successful in the end.

By the way, you have already been using branches since the beginning of this part. Indeed, the default branch is called "*master*" (or sometimes "*main*").

Thanks to this system of branches, we obtain a tree of the different *commits* over time (where the nodes correspond to the separation of the branches).


### *Merge*
  
A so-called "*pull*" can be decomposed into 2 actions made by `git`: 
  
  1. first a *fetch*, which corresponds to downloading the online code
  
  2. immediately followed by a *merge*, which merges the local version with the downloaded changes.
  
After conducting experimental development in one branch one may want to *merge* these changes into the "master" branch for example, once the experiment has proved successful.
  
If the changes concern separate parts of the code, then *merging* can be done without any problem. On the other hand, if the two versions to be *merged* both contain changes which concern the **same lines of code** since their last **common** *commit* , then we will encounter one (or more) **conflicts**, which we will have to be manually resolved.
  

### Conflicts

Let's take the following example: the developer $D_1$ and the developer $D_2$ have both *pulled* the version v0.1 of the code at time $t$ on their respective machines. They each work independently to make changes to the code. When *pushing* his/her changes, developer $D_2$ receives an error message: 

`"Sync Error.`  
`Please resolve all conflicted files, commit, then try syncing again."`

Chaque fichier étant source de conflit a alors été automatiquement édité comme suit :
```{git, eval = FALSE}
<<<<<<< HEAD
local code
=======
online code
>>>>>>> remote
```

In order to solve the conflict, you have to manually and carefully edit each file one by one, choosing whether to keep the local or the online version of the code, before you can *commit* again, and finally successfully *push* your changes online.

> `r emoji::emoji("point_right")` ***Your turn !*** 
>
  1. Edit the `README.Rmd` file of your paired buddy, then *commit* your change, and finally *push* them.
>
  2. Once your buddy has modified your own `README.Rmd` modify the file on the same line (make sure by discussing it together), **WITHOUT* *pulling* your buddy's changes first! *Comment* and try to *push* these changes.
>
  3. Resolve the conflict.

**NB:** In real life you want to avoid this situation and always *pull* before *pushing*, here we purposedly do the opposite for the sake of providing an example and demystifying conflicts.


### *Fork*

A *fork* allows you to create a copy of your own from an available code repository. Thus the original code will not be impacted by your changes. This is like creating a branch, and severing it from the tree, so you can assume ownership of it. It could also have been called a "cutting" to continue the metaphor...

This action is mainly useful for *pull requests* (see next).



### *Pull request*

*Pull requests* are the easiest way to propose changes in a code project which you are not a contributor of. GitHub provides a graphical interface that makes this easy to do so.

> `r emoji::emoji("point_right")` ***Your turn !*** 
>
  1. Modify the `README.Rmd` of your neighbor who is **NOT** your paired-buddy after *forking* his package.
>
  2. Propose your change in the form of a *pull request* from their GitHub repository webpage ("Pull request"s tab).
>
  3. Accept your own neighbor *pull request* on your repository GitHub website, and then *merge* it.



### *Issues*

Pour n'importe quel répertoire GitHub, vous pouvez poster un commentaire sous forme d'*issue* afin d'alerter les développeurs sur un éventuel bug, ou une question sur l'utilisation du package, ou encore demander une fonctionnalité supplémentaire...

L'idéal est de proposer vous-même une *pull request* qui résout votre *issue* lorsque vous le pouvez (i.e. en avez les capacités et le temps).

> `r emoji::emoji("point_right")` ***Your turn !*** 
>
  1. Utilisez `usethis::use_github_links()` afin d'ajouter les 2 lignes suivantes au fichier `DESCRIPTION` de votre package  
`URL: http://github.com/*prenom.nom*/mypkg`  
`BugReports: http://github.com/*prenom.nom*/mypkg/issues`
>
  2. Visualisez les nouveau changements, puis *commitez* les.
>
  3. Créez une *issue* sur le projet de votre binome

## Intégration continue

À chaque changement, à chaque *commit* donc, il y a la possibilité d'introduire 1 (ou plusieurs) bugs qui vont empêcher le package de passer le *CRAN check*. Si l'on accumule trop de ces bugs, au moment de soumettre la nouvelle version, il peut y avoir beaucoup de corrections à apporter. C'est d'autant plus frustrant si le package passait le *CRAN check* auparavant... 


Les services d'intégration continue permettent de *checker* votre package **automatiquement** après chaque *commit* ! En cas d'échec, vous recevez un mail qui vous en informe. Un certain nombre de ces services proposent une offre limitée gratuite pour les projets open-source. 

Une autre raison d'utiliser l'intégration continue est qu'elle permet de tester votre package sur des infrastructures différentes de la votre (e.g. Windows, Ubuntu, Mac OS) et pour différentes versions de `r fontawesome::fa("r-project")` (*current*, *devel*...)

### *GitHub Actions*

Les Github actions permettent de lancer des actions automatiquement à chaque fois que vous pushez sur GitHub La commande `usethis::use_github_action_check_standard()` permet d'initialiser les *Github Actions*, et d'ajouter l'action `R CMD CHECK` du package.

> ***A vous de jouer !***
>
  1. Executez la commande `usethis::use_github_action_check_standard()` et *commitez* les changements et regardez ce qu'il se passe sur la page GitHub
>
  2. Ajouter un badge à votre README.md grâce au code obtenu dans la console R et *commitez ces changements*


N'hésitez pas à consulter la page suivantes qui renseigne sur les différentes *GitHub Actions* disponibles pour les pacakges `r fontawesome::fa("r-project")` : [https://github.com/r-lib/actions/blob/v1/examples/README.md](https://github.com/r-lib/actions/blob/v1/examples/README.md)



### R-hub

Le *R consortium* met à disposition le [R-hub builder](https://www.r-consortium.org/blog/2016/06/06/first-public-version-of-the-r-hub-builder), et a pour ambition de bientôt proposer un service d'intégration continue spécialement dédié aux packages `r fontawesome::fa("r-project")`.



## Annexe 2.1 : couverture du code

Le package `covr` propose une solution pour mesurer la couverture des tests unitaires associés à un 
package. La couverture de test détermine la proportion du code source qui est effectivement utilisée
lors de l’exécution des tests unitaires. La mesure de la couverture du code renforce la fiabilité
d'un code et donne confiance à ses utilisateurs potentiels.

> `r emoji::emoji("point_right")` ***Your turn !*** 
>
  1. Executez la commande `usethis::use_coverage()`,  ajouter un joli badge à votre README.md grâce au code obtenu dans la console R

>  
  2. *Commitez* ces changements.

Pour plus d'information n'hésitez pas à consulter la [vignette](https://cran.r-project.org/web/packages/covr/vignettes/how_it_works.html) de `covr`.

